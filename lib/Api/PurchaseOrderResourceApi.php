<?php
/**
 * PurchaseOrderResourceApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * # Documentation   The Fortnox API is organized around REST. This means that weâ€™ve designed it to have resource-oriented URLs and be as predictable as possible for you as developer.  It also means that we use HTTP status codes when something goes wrong and HTTP verbs understod by many API clients around the web.  We use a modified version of OAuth2 for authentication to offer a secure way for both you and our users to interact.  The API is generally built to support both XML and JSON but in this documentation all the examples will be in JSON.  We encourage you to read all the articles in the [Guides & Good to Know section](https://www.fortnox.se/developer/guides-and-good-to-know/)</a> first, before going forward and learning about the different resources.  This to ensure you get an understanding of some of the shared components of the API such as parameters and error handling.  ## Rate limits  The limit per access-token is 25 requests per 5 seconds. This equals to 300 requests per minute.  [Read more about this here.](https://www.fortnox.se/developer/guides-and-good-to-know/rate-limits-for-fortnox-api/)  ## Query parameters  Use query parameters with the ?-character and separate parameters with the &-character.   **Example:**  GET - https://api.fortnox.se/3/invoices?accountnumberfrom=3000&accountnumberto=4000 Read more about our parameters [here](https://www.fortnox.se/developer/guides-and-good-to-know/parameters/)   Search the documentation using the search field in the top left corner.
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * PurchaseOrderResourceApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class PurchaseOrderResourceApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'batchUpdateResponseState' => [
            'application/json',
        ],
        'createPurchaseOrderResource' => [
            'application/json',
        ],
        'getAllPurchaseOrderResource' => [
            'application/json',
        ],
        'getAttachedNotes' => [
            'application/json',
        ],
        'getCsvReport' => [
            'application/json',
        ],
        'getMatchedDocuments' => [
            'application/json',
        ],
        'getPurchaseOrderResource' => [
            'application/json',
        ],
        'sendPurchaseOrder' => [
            'application/json',
        ],
        'sendPurchaseOrders' => [
            'application/json',
        ],
        'setDropshipManuallyCompleted' => [
            'application/json',
        ],
        'setManuallyCompleted' => [
            'application/json',
        ],
        'updatePurchaseOrderResource' => [
            'application/json',
        ],
        'updateResponseState' => [
            'application/json',
        ],
        'voidDocumentPurchaseOrderResource' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation batchUpdateResponseState
     *
     * Update response states
     *
     * @param  int[] $ids List of purchase order ids. (optional)
     * @param  \OpenAPI\Client\Model\ResponseStateChange $response_state_change The new response state. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchUpdateResponseState'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PurchaseOrder[]
     */
    public function batchUpdateResponseState($ids = null, $response_state_change = null, string $contentType = self::contentTypes['batchUpdateResponseState'][0])
    {
        list($response) = $this->batchUpdateResponseStateWithHttpInfo($ids, $response_state_change, $contentType);
        return $response;
    }

    /**
     * Operation batchUpdateResponseStateWithHttpInfo
     *
     * Update response states
     *
     * @param  int[] $ids List of purchase order ids. (optional)
     * @param  \OpenAPI\Client\Model\ResponseStateChange $response_state_change The new response state. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchUpdateResponseState'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PurchaseOrder[], HTTP status code, HTTP response headers (array of strings)
     */
    public function batchUpdateResponseStateWithHttpInfo($ids = null, $response_state_change = null, string $contentType = self::contentTypes['batchUpdateResponseState'][0])
    {
        $request = $this->batchUpdateResponseStateRequest($ids, $response_state_change, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PurchaseOrder[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PurchaseOrder[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PurchaseOrder[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PurchaseOrder[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PurchaseOrder[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation batchUpdateResponseStateAsync
     *
     * Update response states
     *
     * @param  int[] $ids List of purchase order ids. (optional)
     * @param  \OpenAPI\Client\Model\ResponseStateChange $response_state_change The new response state. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchUpdateResponseState'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function batchUpdateResponseStateAsync($ids = null, $response_state_change = null, string $contentType = self::contentTypes['batchUpdateResponseState'][0])
    {
        return $this->batchUpdateResponseStateAsyncWithHttpInfo($ids, $response_state_change, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation batchUpdateResponseStateAsyncWithHttpInfo
     *
     * Update response states
     *
     * @param  int[] $ids List of purchase order ids. (optional)
     * @param  \OpenAPI\Client\Model\ResponseStateChange $response_state_change The new response state. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchUpdateResponseState'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function batchUpdateResponseStateAsyncWithHttpInfo($ids = null, $response_state_change = null, string $contentType = self::contentTypes['batchUpdateResponseState'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PurchaseOrder[]';
        $request = $this->batchUpdateResponseStateRequest($ids, $response_state_change, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'batchUpdateResponseState'
     *
     * @param  int[] $ids List of purchase order ids. (optional)
     * @param  \OpenAPI\Client\Model\ResponseStateChange $response_state_change The new response state. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchUpdateResponseState'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function batchUpdateResponseStateRequest($ids = null, $response_state_change = null, string $contentType = self::contentTypes['batchUpdateResponseState'][0])
    {




        $resourcePath = '/api/warehouse/purchaseorders-v1/response';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($response_state_change)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($response_state_change));
            } else {
                $httpBody = $response_state_change;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createPurchaseOrderResource
     *
     * Create Purchase Order
     *
     * @param  \OpenAPI\Client\Model\PurchaseOrder $purchase_order &lt;code&gt;PurchaseOrder&lt;/code&gt; document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PurchaseOrder
     */
    public function createPurchaseOrderResource($purchase_order = null, string $contentType = self::contentTypes['createPurchaseOrderResource'][0])
    {
        list($response) = $this->createPurchaseOrderResourceWithHttpInfo($purchase_order, $contentType);
        return $response;
    }

    /**
     * Operation createPurchaseOrderResourceWithHttpInfo
     *
     * Create Purchase Order
     *
     * @param  \OpenAPI\Client\Model\PurchaseOrder $purchase_order &lt;code&gt;PurchaseOrder&lt;/code&gt; document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PurchaseOrder, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPurchaseOrderResourceWithHttpInfo($purchase_order = null, string $contentType = self::contentTypes['createPurchaseOrderResource'][0])
    {
        $request = $this->createPurchaseOrderResourceRequest($purchase_order, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PurchaseOrder' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PurchaseOrder' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PurchaseOrder', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PurchaseOrder';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PurchaseOrder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPurchaseOrderResourceAsync
     *
     * Create Purchase Order
     *
     * @param  \OpenAPI\Client\Model\PurchaseOrder $purchase_order &lt;code&gt;PurchaseOrder&lt;/code&gt; document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPurchaseOrderResourceAsync($purchase_order = null, string $contentType = self::contentTypes['createPurchaseOrderResource'][0])
    {
        return $this->createPurchaseOrderResourceAsyncWithHttpInfo($purchase_order, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPurchaseOrderResourceAsyncWithHttpInfo
     *
     * Create Purchase Order
     *
     * @param  \OpenAPI\Client\Model\PurchaseOrder $purchase_order &lt;code&gt;PurchaseOrder&lt;/code&gt; document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPurchaseOrderResourceAsyncWithHttpInfo($purchase_order = null, string $contentType = self::contentTypes['createPurchaseOrderResource'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PurchaseOrder';
        $request = $this->createPurchaseOrderResourceRequest($purchase_order, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPurchaseOrderResource'
     *
     * @param  \OpenAPI\Client\Model\PurchaseOrder $purchase_order &lt;code&gt;PurchaseOrder&lt;/code&gt; document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createPurchaseOrderResourceRequest($purchase_order = null, string $contentType = self::contentTypes['createPurchaseOrderResource'][0])
    {



        $resourcePath = '/api/warehouse/purchaseorders-v1';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($purchase_order)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($purchase_order));
            } else {
                $httpBody = $purchase_order;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllPurchaseOrderResource
     *
     * List Purchase Orders
     *
     * @param  string $q Include only documents where &#x60;id&#x60; or &#x60;internalReference&#x60;-field contains the given text (case-insensitive). (optional)
     * @param  string $supplier_number Include only documents with the given &#x60;supplierNumber&#x60;. (optional)
     * @param  string $state Include only documents with the given &#x60;purchaseOrderState&#x60;. (optional)
     * @param  string $item_id Include only documents with the given &#x60;itemId&#x60;. (optional)
     * @param  string $purchase_type Include only documents with the given &#x60;purchaseType&#x60; (optional)
     * @param  string $internal_reference Include only documents where &#x60;internalReference&#39; contains the given text (case-insensitive). (optional)
     * @param  string $note Include only documents where &#x60;note&#x60;-field contains the given text (case-insensitive). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllPurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PurchaseOrder[]
     */
    public function getAllPurchaseOrderResource($q = null, $supplier_number = null, $state = null, $item_id = null, $purchase_type = null, $internal_reference = null, $note = null, string $contentType = self::contentTypes['getAllPurchaseOrderResource'][0])
    {
        list($response) = $this->getAllPurchaseOrderResourceWithHttpInfo($q, $supplier_number, $state, $item_id, $purchase_type, $internal_reference, $note, $contentType);
        return $response;
    }

    /**
     * Operation getAllPurchaseOrderResourceWithHttpInfo
     *
     * List Purchase Orders
     *
     * @param  string $q Include only documents where &#x60;id&#x60; or &#x60;internalReference&#x60;-field contains the given text (case-insensitive). (optional)
     * @param  string $supplier_number Include only documents with the given &#x60;supplierNumber&#x60;. (optional)
     * @param  string $state Include only documents with the given &#x60;purchaseOrderState&#x60;. (optional)
     * @param  string $item_id Include only documents with the given &#x60;itemId&#x60;. (optional)
     * @param  string $purchase_type Include only documents with the given &#x60;purchaseType&#x60; (optional)
     * @param  string $internal_reference Include only documents where &#x60;internalReference&#39; contains the given text (case-insensitive). (optional)
     * @param  string $note Include only documents where &#x60;note&#x60;-field contains the given text (case-insensitive). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllPurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PurchaseOrder[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllPurchaseOrderResourceWithHttpInfo($q = null, $supplier_number = null, $state = null, $item_id = null, $purchase_type = null, $internal_reference = null, $note = null, string $contentType = self::contentTypes['getAllPurchaseOrderResource'][0])
    {
        $request = $this->getAllPurchaseOrderResourceRequest($q, $supplier_number, $state, $item_id, $purchase_type, $internal_reference, $note, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PurchaseOrder[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PurchaseOrder[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PurchaseOrder[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PurchaseOrder[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PurchaseOrder[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllPurchaseOrderResourceAsync
     *
     * List Purchase Orders
     *
     * @param  string $q Include only documents where &#x60;id&#x60; or &#x60;internalReference&#x60;-field contains the given text (case-insensitive). (optional)
     * @param  string $supplier_number Include only documents with the given &#x60;supplierNumber&#x60;. (optional)
     * @param  string $state Include only documents with the given &#x60;purchaseOrderState&#x60;. (optional)
     * @param  string $item_id Include only documents with the given &#x60;itemId&#x60;. (optional)
     * @param  string $purchase_type Include only documents with the given &#x60;purchaseType&#x60; (optional)
     * @param  string $internal_reference Include only documents where &#x60;internalReference&#39; contains the given text (case-insensitive). (optional)
     * @param  string $note Include only documents where &#x60;note&#x60;-field contains the given text (case-insensitive). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllPurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllPurchaseOrderResourceAsync($q = null, $supplier_number = null, $state = null, $item_id = null, $purchase_type = null, $internal_reference = null, $note = null, string $contentType = self::contentTypes['getAllPurchaseOrderResource'][0])
    {
        return $this->getAllPurchaseOrderResourceAsyncWithHttpInfo($q, $supplier_number, $state, $item_id, $purchase_type, $internal_reference, $note, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllPurchaseOrderResourceAsyncWithHttpInfo
     *
     * List Purchase Orders
     *
     * @param  string $q Include only documents where &#x60;id&#x60; or &#x60;internalReference&#x60;-field contains the given text (case-insensitive). (optional)
     * @param  string $supplier_number Include only documents with the given &#x60;supplierNumber&#x60;. (optional)
     * @param  string $state Include only documents with the given &#x60;purchaseOrderState&#x60;. (optional)
     * @param  string $item_id Include only documents with the given &#x60;itemId&#x60;. (optional)
     * @param  string $purchase_type Include only documents with the given &#x60;purchaseType&#x60; (optional)
     * @param  string $internal_reference Include only documents where &#x60;internalReference&#39; contains the given text (case-insensitive). (optional)
     * @param  string $note Include only documents where &#x60;note&#x60;-field contains the given text (case-insensitive). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllPurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllPurchaseOrderResourceAsyncWithHttpInfo($q = null, $supplier_number = null, $state = null, $item_id = null, $purchase_type = null, $internal_reference = null, $note = null, string $contentType = self::contentTypes['getAllPurchaseOrderResource'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PurchaseOrder[]';
        $request = $this->getAllPurchaseOrderResourceRequest($q, $supplier_number, $state, $item_id, $purchase_type, $internal_reference, $note, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllPurchaseOrderResource'
     *
     * @param  string $q Include only documents where &#x60;id&#x60; or &#x60;internalReference&#x60;-field contains the given text (case-insensitive). (optional)
     * @param  string $supplier_number Include only documents with the given &#x60;supplierNumber&#x60;. (optional)
     * @param  string $state Include only documents with the given &#x60;purchaseOrderState&#x60;. (optional)
     * @param  string $item_id Include only documents with the given &#x60;itemId&#x60;. (optional)
     * @param  string $purchase_type Include only documents with the given &#x60;purchaseType&#x60; (optional)
     * @param  string $internal_reference Include only documents where &#x60;internalReference&#39; contains the given text (case-insensitive). (optional)
     * @param  string $note Include only documents where &#x60;note&#x60;-field contains the given text (case-insensitive). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllPurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAllPurchaseOrderResourceRequest($q = null, $supplier_number = null, $state = null, $item_id = null, $purchase_type = null, $internal_reference = null, $note = null, string $contentType = self::contentTypes['getAllPurchaseOrderResource'][0])
    {









        $resourcePath = '/api/warehouse/purchaseorders-v1';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supplier_number,
            'supplierNumber', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $state,
            'state', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_id,
            'itemId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $purchase_type,
            'purchaseType', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $internal_reference,
            'internalReference', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $note,
            'note', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAttachedNotes
     *
     * Get notes
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAttachedNotes'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PurchaseOrderRowNote[]
     */
    public function getAttachedNotes($id, string $contentType = self::contentTypes['getAttachedNotes'][0])
    {
        list($response) = $this->getAttachedNotesWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getAttachedNotesWithHttpInfo
     *
     * Get notes
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAttachedNotes'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PurchaseOrderRowNote[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getAttachedNotesWithHttpInfo($id, string $contentType = self::contentTypes['getAttachedNotes'][0])
    {
        $request = $this->getAttachedNotesRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PurchaseOrderRowNote[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PurchaseOrderRowNote[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PurchaseOrderRowNote[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PurchaseOrderRowNote[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PurchaseOrderRowNote[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAttachedNotesAsync
     *
     * Get notes
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAttachedNotes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAttachedNotesAsync($id, string $contentType = self::contentTypes['getAttachedNotes'][0])
    {
        return $this->getAttachedNotesAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAttachedNotesAsyncWithHttpInfo
     *
     * Get notes
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAttachedNotes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAttachedNotesAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getAttachedNotes'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PurchaseOrderRowNote[]';
        $request = $this->getAttachedNotesRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAttachedNotes'
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAttachedNotes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAttachedNotesRequest($id, string $contentType = self::contentTypes['getAttachedNotes'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getAttachedNotes'
            );
        }


        $resourcePath = '/api/warehouse/purchaseorders-v1/{id}/notes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCsvReport
     *
     * Get CSV list of Purchase Orders
     *
     * @param  string $q Include only documents where &#x60;id&#x60; or &#x60;internalReference&#x60;-field contains the given text (case-insensitive). (optional)
     * @param  string $supplier_number Include only documents with the given &#x60;supplierNumber&#x60;. (optional)
     * @param  string $state Include only documents with the given &#x60;purchaseOrderState&#x60;. (optional)
     * @param  string $item_id Include only documents with the given &#x60;itemId&#x60;. (optional)
     * @param  string $purchase_type Include only documents with the given &#x60;purchaseType&#x60; (optional)
     * @param  string $internal_reference Include only documents where &#x60;internalReference&#39; contains the given text (case-insensitive). (optional)
     * @param  string $note Include only documents where &#x60;note&#x60;-field contains the given text (case-insensitive). (optional)
     * @param  bool $show_purchase_type_column True to include the purchase type column, default is false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCsvReport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getCsvReport($q = null, $supplier_number = null, $state = null, $item_id = null, $purchase_type = null, $internal_reference = null, $note = null, $show_purchase_type_column = null, string $contentType = self::contentTypes['getCsvReport'][0])
    {
        list($response) = $this->getCsvReportWithHttpInfo($q, $supplier_number, $state, $item_id, $purchase_type, $internal_reference, $note, $show_purchase_type_column, $contentType);
        return $response;
    }

    /**
     * Operation getCsvReportWithHttpInfo
     *
     * Get CSV list of Purchase Orders
     *
     * @param  string $q Include only documents where &#x60;id&#x60; or &#x60;internalReference&#x60;-field contains the given text (case-insensitive). (optional)
     * @param  string $supplier_number Include only documents with the given &#x60;supplierNumber&#x60;. (optional)
     * @param  string $state Include only documents with the given &#x60;purchaseOrderState&#x60;. (optional)
     * @param  string $item_id Include only documents with the given &#x60;itemId&#x60;. (optional)
     * @param  string $purchase_type Include only documents with the given &#x60;purchaseType&#x60; (optional)
     * @param  string $internal_reference Include only documents where &#x60;internalReference&#39; contains the given text (case-insensitive). (optional)
     * @param  string $note Include only documents where &#x60;note&#x60;-field contains the given text (case-insensitive). (optional)
     * @param  bool $show_purchase_type_column True to include the purchase type column, default is false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCsvReport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCsvReportWithHttpInfo($q = null, $supplier_number = null, $state = null, $item_id = null, $purchase_type = null, $internal_reference = null, $note = null, $show_purchase_type_column = null, string $contentType = self::contentTypes['getCsvReport'][0])
    {
        $request = $this->getCsvReportRequest($q, $supplier_number, $state, $item_id, $purchase_type, $internal_reference, $note, $show_purchase_type_column, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCsvReportAsync
     *
     * Get CSV list of Purchase Orders
     *
     * @param  string $q Include only documents where &#x60;id&#x60; or &#x60;internalReference&#x60;-field contains the given text (case-insensitive). (optional)
     * @param  string $supplier_number Include only documents with the given &#x60;supplierNumber&#x60;. (optional)
     * @param  string $state Include only documents with the given &#x60;purchaseOrderState&#x60;. (optional)
     * @param  string $item_id Include only documents with the given &#x60;itemId&#x60;. (optional)
     * @param  string $purchase_type Include only documents with the given &#x60;purchaseType&#x60; (optional)
     * @param  string $internal_reference Include only documents where &#x60;internalReference&#39; contains the given text (case-insensitive). (optional)
     * @param  string $note Include only documents where &#x60;note&#x60;-field contains the given text (case-insensitive). (optional)
     * @param  bool $show_purchase_type_column True to include the purchase type column, default is false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCsvReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCsvReportAsync($q = null, $supplier_number = null, $state = null, $item_id = null, $purchase_type = null, $internal_reference = null, $note = null, $show_purchase_type_column = null, string $contentType = self::contentTypes['getCsvReport'][0])
    {
        return $this->getCsvReportAsyncWithHttpInfo($q, $supplier_number, $state, $item_id, $purchase_type, $internal_reference, $note, $show_purchase_type_column, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCsvReportAsyncWithHttpInfo
     *
     * Get CSV list of Purchase Orders
     *
     * @param  string $q Include only documents where &#x60;id&#x60; or &#x60;internalReference&#x60;-field contains the given text (case-insensitive). (optional)
     * @param  string $supplier_number Include only documents with the given &#x60;supplierNumber&#x60;. (optional)
     * @param  string $state Include only documents with the given &#x60;purchaseOrderState&#x60;. (optional)
     * @param  string $item_id Include only documents with the given &#x60;itemId&#x60;. (optional)
     * @param  string $purchase_type Include only documents with the given &#x60;purchaseType&#x60; (optional)
     * @param  string $internal_reference Include only documents where &#x60;internalReference&#39; contains the given text (case-insensitive). (optional)
     * @param  string $note Include only documents where &#x60;note&#x60;-field contains the given text (case-insensitive). (optional)
     * @param  bool $show_purchase_type_column True to include the purchase type column, default is false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCsvReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCsvReportAsyncWithHttpInfo($q = null, $supplier_number = null, $state = null, $item_id = null, $purchase_type = null, $internal_reference = null, $note = null, $show_purchase_type_column = null, string $contentType = self::contentTypes['getCsvReport'][0])
    {
        $returnType = 'string';
        $request = $this->getCsvReportRequest($q, $supplier_number, $state, $item_id, $purchase_type, $internal_reference, $note, $show_purchase_type_column, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCsvReport'
     *
     * @param  string $q Include only documents where &#x60;id&#x60; or &#x60;internalReference&#x60;-field contains the given text (case-insensitive). (optional)
     * @param  string $supplier_number Include only documents with the given &#x60;supplierNumber&#x60;. (optional)
     * @param  string $state Include only documents with the given &#x60;purchaseOrderState&#x60;. (optional)
     * @param  string $item_id Include only documents with the given &#x60;itemId&#x60;. (optional)
     * @param  string $purchase_type Include only documents with the given &#x60;purchaseType&#x60; (optional)
     * @param  string $internal_reference Include only documents where &#x60;internalReference&#39; contains the given text (case-insensitive). (optional)
     * @param  string $note Include only documents where &#x60;note&#x60;-field contains the given text (case-insensitive). (optional)
     * @param  bool $show_purchase_type_column True to include the purchase type column, default is false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCsvReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCsvReportRequest($q = null, $supplier_number = null, $state = null, $item_id = null, $purchase_type = null, $internal_reference = null, $note = null, $show_purchase_type_column = null, string $contentType = self::contentTypes['getCsvReport'][0])
    {










        $resourcePath = '/api/warehouse/purchaseorders-v1/csv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supplier_number,
            'supplierNumber', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $state,
            'state', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_id,
            'itemId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $purchase_type,
            'purchaseType', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $internal_reference,
            'internalReference', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $note,
            'note', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_purchase_type_column,
            'showPurchaseTypeColumn', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMatchedDocuments
     *
     * List matched documents
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMatchedDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\DocumentReference[]
     */
    public function getMatchedDocuments($id, string $contentType = self::contentTypes['getMatchedDocuments'][0])
    {
        list($response) = $this->getMatchedDocumentsWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getMatchedDocumentsWithHttpInfo
     *
     * List matched documents
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMatchedDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\DocumentReference[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getMatchedDocumentsWithHttpInfo($id, string $contentType = self::contentTypes['getMatchedDocuments'][0])
    {
        $request = $this->getMatchedDocumentsRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\DocumentReference[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\DocumentReference[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DocumentReference[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\DocumentReference[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DocumentReference[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMatchedDocumentsAsync
     *
     * List matched documents
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMatchedDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMatchedDocumentsAsync($id, string $contentType = self::contentTypes['getMatchedDocuments'][0])
    {
        return $this->getMatchedDocumentsAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMatchedDocumentsAsyncWithHttpInfo
     *
     * List matched documents
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMatchedDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMatchedDocumentsAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getMatchedDocuments'][0])
    {
        $returnType = '\OpenAPI\Client\Model\DocumentReference[]';
        $request = $this->getMatchedDocumentsRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMatchedDocuments'
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMatchedDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMatchedDocumentsRequest($id, string $contentType = self::contentTypes['getMatchedDocuments'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getMatchedDocuments'
            );
        }


        $resourcePath = '/api/warehouse/purchaseorders-v1/{id}/matches';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPurchaseOrderResource
     *
     * Get Purchase Order
     *
     * @param  int $id Purchase order id. (required)
     * @param  int $ignore_incoming_goods_id used for calculating the remaining ordered quantity. null will take the received quantity from all incoming goods (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PurchaseOrder
     */
    public function getPurchaseOrderResource($id, $ignore_incoming_goods_id = null, string $contentType = self::contentTypes['getPurchaseOrderResource'][0])
    {
        list($response) = $this->getPurchaseOrderResourceWithHttpInfo($id, $ignore_incoming_goods_id, $contentType);
        return $response;
    }

    /**
     * Operation getPurchaseOrderResourceWithHttpInfo
     *
     * Get Purchase Order
     *
     * @param  int $id Purchase order id. (required)
     * @param  int $ignore_incoming_goods_id used for calculating the remaining ordered quantity. null will take the received quantity from all incoming goods (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PurchaseOrder, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPurchaseOrderResourceWithHttpInfo($id, $ignore_incoming_goods_id = null, string $contentType = self::contentTypes['getPurchaseOrderResource'][0])
    {
        $request = $this->getPurchaseOrderResourceRequest($id, $ignore_incoming_goods_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PurchaseOrder' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PurchaseOrder' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PurchaseOrder', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PurchaseOrder';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PurchaseOrder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPurchaseOrderResourceAsync
     *
     * Get Purchase Order
     *
     * @param  int $id Purchase order id. (required)
     * @param  int $ignore_incoming_goods_id used for calculating the remaining ordered quantity. null will take the received quantity from all incoming goods (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPurchaseOrderResourceAsync($id, $ignore_incoming_goods_id = null, string $contentType = self::contentTypes['getPurchaseOrderResource'][0])
    {
        return $this->getPurchaseOrderResourceAsyncWithHttpInfo($id, $ignore_incoming_goods_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPurchaseOrderResourceAsyncWithHttpInfo
     *
     * Get Purchase Order
     *
     * @param  int $id Purchase order id. (required)
     * @param  int $ignore_incoming_goods_id used for calculating the remaining ordered quantity. null will take the received quantity from all incoming goods (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPurchaseOrderResourceAsyncWithHttpInfo($id, $ignore_incoming_goods_id = null, string $contentType = self::contentTypes['getPurchaseOrderResource'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PurchaseOrder';
        $request = $this->getPurchaseOrderResourceRequest($id, $ignore_incoming_goods_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPurchaseOrderResource'
     *
     * @param  int $id Purchase order id. (required)
     * @param  int $ignore_incoming_goods_id used for calculating the remaining ordered quantity. null will take the received quantity from all incoming goods (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPurchaseOrderResourceRequest($id, $ignore_incoming_goods_id = null, string $contentType = self::contentTypes['getPurchaseOrderResource'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getPurchaseOrderResource'
            );
        }



        $resourcePath = '/api/warehouse/purchaseorders-v1/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ignore_incoming_goods_id,
            'ignoreIncomingGoodsId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendPurchaseOrder
     *
     * Send purchase order via email
     *
     * @param  int $id Purchase order id. (required)
     * @param  \OpenAPI\Client\Model\PurchaseOrderMailSettings $settings see &lt;code&gt;PurchaseOrderMailSettings&lt;/code&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendPurchaseOrder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function sendPurchaseOrder($id, $settings = null, string $contentType = self::contentTypes['sendPurchaseOrder'][0])
    {
        $this->sendPurchaseOrderWithHttpInfo($id, $settings, $contentType);
    }

    /**
     * Operation sendPurchaseOrderWithHttpInfo
     *
     * Send purchase order via email
     *
     * @param  int $id Purchase order id. (required)
     * @param  \OpenAPI\Client\Model\PurchaseOrderMailSettings $settings see &lt;code&gt;PurchaseOrderMailSettings&lt;/code&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendPurchaseOrder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendPurchaseOrderWithHttpInfo($id, $settings = null, string $contentType = self::contentTypes['sendPurchaseOrder'][0])
    {
        $request = $this->sendPurchaseOrderRequest($id, $settings, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation sendPurchaseOrderAsync
     *
     * Send purchase order via email
     *
     * @param  int $id Purchase order id. (required)
     * @param  \OpenAPI\Client\Model\PurchaseOrderMailSettings $settings see &lt;code&gt;PurchaseOrderMailSettings&lt;/code&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendPurchaseOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendPurchaseOrderAsync($id, $settings = null, string $contentType = self::contentTypes['sendPurchaseOrder'][0])
    {
        return $this->sendPurchaseOrderAsyncWithHttpInfo($id, $settings, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendPurchaseOrderAsyncWithHttpInfo
     *
     * Send purchase order via email
     *
     * @param  int $id Purchase order id. (required)
     * @param  \OpenAPI\Client\Model\PurchaseOrderMailSettings $settings see &lt;code&gt;PurchaseOrderMailSettings&lt;/code&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendPurchaseOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendPurchaseOrderAsyncWithHttpInfo($id, $settings = null, string $contentType = self::contentTypes['sendPurchaseOrder'][0])
    {
        $returnType = '';
        $request = $this->sendPurchaseOrderRequest($id, $settings, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendPurchaseOrder'
     *
     * @param  int $id Purchase order id. (required)
     * @param  \OpenAPI\Client\Model\PurchaseOrderMailSettings $settings see &lt;code&gt;PurchaseOrderMailSettings&lt;/code&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendPurchaseOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sendPurchaseOrderRequest($id, $settings = null, string $contentType = self::contentTypes['sendPurchaseOrder'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling sendPurchaseOrder'
            );
        }



        $resourcePath = '/api/warehouse/purchaseorders-v1/{id}/send';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($settings)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($settings));
            } else {
                $httpBody = $settings;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendPurchaseOrders
     *
     * Sends multiple purchase orders via email
     *
     * @param  int[] $purchase_order_ids List of Purchase order ids. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendPurchaseOrders'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function sendPurchaseOrders($purchase_order_ids = null, string $contentType = self::contentTypes['sendPurchaseOrders'][0])
    {
        $this->sendPurchaseOrdersWithHttpInfo($purchase_order_ids, $contentType);
    }

    /**
     * Operation sendPurchaseOrdersWithHttpInfo
     *
     * Sends multiple purchase orders via email
     *
     * @param  int[] $purchase_order_ids List of Purchase order ids. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendPurchaseOrders'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendPurchaseOrdersWithHttpInfo($purchase_order_ids = null, string $contentType = self::contentTypes['sendPurchaseOrders'][0])
    {
        $request = $this->sendPurchaseOrdersRequest($purchase_order_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation sendPurchaseOrdersAsync
     *
     * Sends multiple purchase orders via email
     *
     * @param  int[] $purchase_order_ids List of Purchase order ids. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendPurchaseOrders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendPurchaseOrdersAsync($purchase_order_ids = null, string $contentType = self::contentTypes['sendPurchaseOrders'][0])
    {
        return $this->sendPurchaseOrdersAsyncWithHttpInfo($purchase_order_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendPurchaseOrdersAsyncWithHttpInfo
     *
     * Sends multiple purchase orders via email
     *
     * @param  int[] $purchase_order_ids List of Purchase order ids. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendPurchaseOrders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendPurchaseOrdersAsyncWithHttpInfo($purchase_order_ids = null, string $contentType = self::contentTypes['sendPurchaseOrders'][0])
    {
        $returnType = '';
        $request = $this->sendPurchaseOrdersRequest($purchase_order_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendPurchaseOrders'
     *
     * @param  int[] $purchase_order_ids List of Purchase order ids. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendPurchaseOrders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sendPurchaseOrdersRequest($purchase_order_ids = null, string $contentType = self::contentTypes['sendPurchaseOrders'][0])
    {



        $resourcePath = '/api/warehouse/purchaseorders-v1/sendpurchaseorders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($purchase_order_ids)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($purchase_order_ids));
            } else {
                $httpBody = $purchase_order_ids;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setDropshipManuallyCompleted
     *
     * Manually complete dropship order
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setDropshipManuallyCompleted'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ReleaseParentOrder
     */
    public function setDropshipManuallyCompleted($id, string $contentType = self::contentTypes['setDropshipManuallyCompleted'][0])
    {
        list($response) = $this->setDropshipManuallyCompletedWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation setDropshipManuallyCompletedWithHttpInfo
     *
     * Manually complete dropship order
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setDropshipManuallyCompleted'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ReleaseParentOrder, HTTP status code, HTTP response headers (array of strings)
     */
    public function setDropshipManuallyCompletedWithHttpInfo($id, string $contentType = self::contentTypes['setDropshipManuallyCompleted'][0])
    {
        $request = $this->setDropshipManuallyCompletedRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ReleaseParentOrder' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ReleaseParentOrder' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ReleaseParentOrder', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ReleaseParentOrder';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ReleaseParentOrder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setDropshipManuallyCompletedAsync
     *
     * Manually complete dropship order
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setDropshipManuallyCompleted'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setDropshipManuallyCompletedAsync($id, string $contentType = self::contentTypes['setDropshipManuallyCompleted'][0])
    {
        return $this->setDropshipManuallyCompletedAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setDropshipManuallyCompletedAsyncWithHttpInfo
     *
     * Manually complete dropship order
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setDropshipManuallyCompleted'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setDropshipManuallyCompletedAsyncWithHttpInfo($id, string $contentType = self::contentTypes['setDropshipManuallyCompleted'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ReleaseParentOrder';
        $request = $this->setDropshipManuallyCompletedRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setDropshipManuallyCompleted'
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setDropshipManuallyCompleted'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setDropshipManuallyCompletedRequest($id, string $contentType = self::contentTypes['setDropshipManuallyCompleted'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling setDropshipManuallyCompleted'
            );
        }


        $resourcePath = '/api/warehouse/purchaseorders-v1/{id}/dropshipcomplete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setManuallyCompleted
     *
     * Manually complete Purchase Order
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setManuallyCompleted'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setManuallyCompleted($id, string $contentType = self::contentTypes['setManuallyCompleted'][0])
    {
        $this->setManuallyCompletedWithHttpInfo($id, $contentType);
    }

    /**
     * Operation setManuallyCompletedWithHttpInfo
     *
     * Manually complete Purchase Order
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setManuallyCompleted'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setManuallyCompletedWithHttpInfo($id, string $contentType = self::contentTypes['setManuallyCompleted'][0])
    {
        $request = $this->setManuallyCompletedRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation setManuallyCompletedAsync
     *
     * Manually complete Purchase Order
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setManuallyCompleted'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setManuallyCompletedAsync($id, string $contentType = self::contentTypes['setManuallyCompleted'][0])
    {
        return $this->setManuallyCompletedAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setManuallyCompletedAsyncWithHttpInfo
     *
     * Manually complete Purchase Order
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setManuallyCompleted'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setManuallyCompletedAsyncWithHttpInfo($id, string $contentType = self::contentTypes['setManuallyCompleted'][0])
    {
        $returnType = '';
        $request = $this->setManuallyCompletedRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setManuallyCompleted'
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setManuallyCompleted'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setManuallyCompletedRequest($id, string $contentType = self::contentTypes['setManuallyCompleted'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling setManuallyCompleted'
            );
        }


        $resourcePath = '/api/warehouse/purchaseorders-v1/{id}/complete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePurchaseOrderResource
     *
     * Update Purchase Order
     *
     * @param  int $id Purchase order id. (required)
     * @param  \OpenAPI\Client\Model\PurchaseOrder $purchase_order The &lt;code&gt;PurchaseOrder&lt;/code&gt; document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PurchaseOrder
     */
    public function updatePurchaseOrderResource($id, $purchase_order = null, string $contentType = self::contentTypes['updatePurchaseOrderResource'][0])
    {
        list($response) = $this->updatePurchaseOrderResourceWithHttpInfo($id, $purchase_order, $contentType);
        return $response;
    }

    /**
     * Operation updatePurchaseOrderResourceWithHttpInfo
     *
     * Update Purchase Order
     *
     * @param  int $id Purchase order id. (required)
     * @param  \OpenAPI\Client\Model\PurchaseOrder $purchase_order The &lt;code&gt;PurchaseOrder&lt;/code&gt; document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PurchaseOrder, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePurchaseOrderResourceWithHttpInfo($id, $purchase_order = null, string $contentType = self::contentTypes['updatePurchaseOrderResource'][0])
    {
        $request = $this->updatePurchaseOrderResourceRequest($id, $purchase_order, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PurchaseOrder' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PurchaseOrder' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PurchaseOrder', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PurchaseOrder';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PurchaseOrder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatePurchaseOrderResourceAsync
     *
     * Update Purchase Order
     *
     * @param  int $id Purchase order id. (required)
     * @param  \OpenAPI\Client\Model\PurchaseOrder $purchase_order The &lt;code&gt;PurchaseOrder&lt;/code&gt; document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePurchaseOrderResourceAsync($id, $purchase_order = null, string $contentType = self::contentTypes['updatePurchaseOrderResource'][0])
    {
        return $this->updatePurchaseOrderResourceAsyncWithHttpInfo($id, $purchase_order, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePurchaseOrderResourceAsyncWithHttpInfo
     *
     * Update Purchase Order
     *
     * @param  int $id Purchase order id. (required)
     * @param  \OpenAPI\Client\Model\PurchaseOrder $purchase_order The &lt;code&gt;PurchaseOrder&lt;/code&gt; document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePurchaseOrderResourceAsyncWithHttpInfo($id, $purchase_order = null, string $contentType = self::contentTypes['updatePurchaseOrderResource'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PurchaseOrder';
        $request = $this->updatePurchaseOrderResourceRequest($id, $purchase_order, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePurchaseOrderResource'
     *
     * @param  int $id Purchase order id. (required)
     * @param  \OpenAPI\Client\Model\PurchaseOrder $purchase_order The &lt;code&gt;PurchaseOrder&lt;/code&gt; document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updatePurchaseOrderResourceRequest($id, $purchase_order = null, string $contentType = self::contentTypes['updatePurchaseOrderResource'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updatePurchaseOrderResource'
            );
        }



        $resourcePath = '/api/warehouse/purchaseorders-v1/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($purchase_order)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($purchase_order));
            } else {
                $httpBody = $purchase_order;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateResponseState
     *
     * Update response state
     *
     * @param  int $id Purchase order id. (required)
     * @param  \OpenAPI\Client\Model\ResponseStateChange $response_state_change The new response state. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateResponseState'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PurchaseOrder
     */
    public function updateResponseState($id, $response_state_change = null, string $contentType = self::contentTypes['updateResponseState'][0])
    {
        list($response) = $this->updateResponseStateWithHttpInfo($id, $response_state_change, $contentType);
        return $response;
    }

    /**
     * Operation updateResponseStateWithHttpInfo
     *
     * Update response state
     *
     * @param  int $id Purchase order id. (required)
     * @param  \OpenAPI\Client\Model\ResponseStateChange $response_state_change The new response state. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateResponseState'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PurchaseOrder, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateResponseStateWithHttpInfo($id, $response_state_change = null, string $contentType = self::contentTypes['updateResponseState'][0])
    {
        $request = $this->updateResponseStateRequest($id, $response_state_change, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PurchaseOrder' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PurchaseOrder' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PurchaseOrder', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PurchaseOrder';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PurchaseOrder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateResponseStateAsync
     *
     * Update response state
     *
     * @param  int $id Purchase order id. (required)
     * @param  \OpenAPI\Client\Model\ResponseStateChange $response_state_change The new response state. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateResponseState'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateResponseStateAsync($id, $response_state_change = null, string $contentType = self::contentTypes['updateResponseState'][0])
    {
        return $this->updateResponseStateAsyncWithHttpInfo($id, $response_state_change, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateResponseStateAsyncWithHttpInfo
     *
     * Update response state
     *
     * @param  int $id Purchase order id. (required)
     * @param  \OpenAPI\Client\Model\ResponseStateChange $response_state_change The new response state. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateResponseState'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateResponseStateAsyncWithHttpInfo($id, $response_state_change = null, string $contentType = self::contentTypes['updateResponseState'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PurchaseOrder';
        $request = $this->updateResponseStateRequest($id, $response_state_change, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateResponseState'
     *
     * @param  int $id Purchase order id. (required)
     * @param  \OpenAPI\Client\Model\ResponseStateChange $response_state_change The new response state. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateResponseState'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateResponseStateRequest($id, $response_state_change = null, string $contentType = self::contentTypes['updateResponseState'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateResponseState'
            );
        }



        $resourcePath = '/api/warehouse/purchaseorders-v1/{id}/response';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($response_state_change)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($response_state_change));
            } else {
                $httpBody = $response_state_change;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation voidDocumentPurchaseOrderResource
     *
     * Void Purchase Order
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['voidDocumentPurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function voidDocumentPurchaseOrderResource($id, string $contentType = self::contentTypes['voidDocumentPurchaseOrderResource'][0])
    {
        $this->voidDocumentPurchaseOrderResourceWithHttpInfo($id, $contentType);
    }

    /**
     * Operation voidDocumentPurchaseOrderResourceWithHttpInfo
     *
     * Void Purchase Order
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['voidDocumentPurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function voidDocumentPurchaseOrderResourceWithHttpInfo($id, string $contentType = self::contentTypes['voidDocumentPurchaseOrderResource'][0])
    {
        $request = $this->voidDocumentPurchaseOrderResourceRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation voidDocumentPurchaseOrderResourceAsync
     *
     * Void Purchase Order
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['voidDocumentPurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voidDocumentPurchaseOrderResourceAsync($id, string $contentType = self::contentTypes['voidDocumentPurchaseOrderResource'][0])
    {
        return $this->voidDocumentPurchaseOrderResourceAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation voidDocumentPurchaseOrderResourceAsyncWithHttpInfo
     *
     * Void Purchase Order
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['voidDocumentPurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voidDocumentPurchaseOrderResourceAsyncWithHttpInfo($id, string $contentType = self::contentTypes['voidDocumentPurchaseOrderResource'][0])
    {
        $returnType = '';
        $request = $this->voidDocumentPurchaseOrderResourceRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'voidDocumentPurchaseOrderResource'
     *
     * @param  int $id Purchase order id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['voidDocumentPurchaseOrderResource'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function voidDocumentPurchaseOrderResourceRequest($id, string $contentType = self::contentTypes['voidDocumentPurchaseOrderResource'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling voidDocumentPurchaseOrderResource'
            );
        }


        $resourcePath = '/api/warehouse/purchaseorders-v1/{id}/void';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
